{"version":3,"file":"html-text.js","sources":["../src/index.js"],"sourcesContent":["import { Sprite } from '@pixi/sprite';\nimport { settings } from '@pixi/settings';\nimport { Texture } from '@pixi/core';\nimport { Rectangle } from '@pixi/math';\nimport { trimCanvas, sign, hex2rgb, hex2string } from '@pixi/utils';\nimport { TextStyle } from '@pixi/text';\n\n/**\n * Text display object that support multi-style HTML text\n * @class\n * @memberof PIXI\n * @extends PIXI.Sprite\n * @see {@link https://pixijs.download/dev/docs/PIXI.Sprite.html PIXI.Sprite}\n * @see {@link https://pixijs.download/dev/docs/PIXI.TextStyle.html PIXI.TextStyle}\n */\nexport class HTMLText extends Sprite\n{\n    /**\n     * @constructor\n     * @param {string} [text] - Text contents\n     * @param {PIXI.TextStyle} [style] - Style settings, not all TextStyle options are supported.\n     * @param {HTMLCanvasElement} [canvas] - Optional canvas to use for rendering.\n     *.       if undefined, will generate it's own canvas using createElement.\n     */\n    constructor(text = '', style = {}, canvas)\n    {\n        canvas = canvas || document.createElement('canvas');\n\n        canvas.width = 3;\n        canvas.height = 3;\n\n        const texture = Texture.from(canvas, { scaleMode: settings.SCALE_MODE });\n\n        texture.orig = new Rectangle();\n        texture.trim = new Rectangle();\n\n        super(texture);\n\n        this._parser = new DOMParser();\n        this._image = new Image();\n\n        this.canvas = canvas;\n        this.context = this.canvas.getContext('2d');\n        this._resolution = settings.RESOLUTION;\n        this._autoResolution = true;\n        this._text = null;\n        this._style = null;\n        this._loading = false;\n        this.text = text;\n        this.style = style;\n        this.localStyleID = -1;\n    }\n\n    /**\n     * Manually refresh the text.\n     * @public\n     * @param {boolean} [respectDirty=true] - Whether to abort updating the\n     *        text if the Text isn't dirty and the function is called.\n     */\n    updateText(respectDirty)\n    {\n        const { style, canvas, context, resolution } = this;\n\n        // check if style has changed..\n        if (this.localStyleID !== style.styleID)\n        {\n            this.dirty = true;\n            this.localStyleID = style.styleID;\n        }\n\n        if (!this.dirty && respectDirty)\n        {\n            return;\n        }\n\n        let css = `\n            display:inline-block;\n            color:${style.fill};\n            font-size: ${style.fontSize}px;\n            font-family:${style.fontFamily};\n            font-weight:${style.fontWeight};\n            font-style:${style.fontStyle};\n            font-variant:${style.fontVariant};\n            letter-spacing:${style.letterSpacing}px;\n            text-align:${style.align};\n            padding:${style.padding}px;\n        `;\n\n        if (style.lineHeight)\n        {\n            css += `line-height:${style.lineHeight}px;`;\n        }\n\n        if (style.wordWrap)\n        {\n            css += `word-wrap:${style.breakWords ? 'break-all' : 'break-word'};`;\n            css += `width:${style.wordWrapWidth}px;`;\n        }\n\n        if (style.strokeThickness)\n        {\n            let { stroke } = style;\n\n            if (typeof color === 'number')\n            {\n                stroke = hex2string(stroke);\n            }\n\n            css += `-webkit-text-stroke-width: ${style.strokeThickness}px;`;\n            css += `-webkit-text-stroke-color: ${stroke};`;\n            css += `text-stroke-width: ${style.strokeThickness}px;`;\n            css += `text-stroke-color: ${stroke};`;\n            css += 'paint-order: stroke;';\n        }\n\n        if (style.dropShadow)\n        {\n            const { dropShadowAngle, dropShadowDistance, dropShadowBlur, dropShadowColor, dropShadowAlpha } = style;\n            const x = Math.round(Math.cos(dropShadowAngle) * dropShadowDistance);\n            const y = Math.round(Math.sin(dropShadowAngle) * dropShadowDistance);\n            let color = dropShadowColor;\n\n            // Convert numbers to hex strings\n            if (typeof color === 'number')\n            {\n                color = hex2string(color);\n            }\n\n            // Check if we should apply alpha\n            if (color.charAt(0) === '#' && dropShadowAlpha < 1)\n            {\n                const [r, g, b] = hex2rgb(parseInt(color.replace('#', ''), 16));\n\n                color = `rgba(${r * 255 | 0}, ${g * 255 | 0}, ${b * 255 | 0}, ${dropShadowAlpha})`;\n            }\n\n            css += `text-shadow: ${x}px ${y}px ${dropShadowBlur}px ${color};`;\n        }\n\n        const svg = `\n            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"2048\" height=\"2048\">\n                <foreignObject width=\"100%\" height=\"100%\">\n                    <div xmlns=\"http://www.w3.org/1999/xhtml\" style=\"${css}\">${this._text}</div>\n                </foreignObject>\n            </svg>\n       `;\n\n        // Used to measure to D\n        const template = this._parser.parseFromString(svg, 'text/xml');\n        const div = template.firstChild.querySelector('div');\n\n        document.body.appendChild(div);\n        const { width, height } = div.getBoundingClientRect();\n\n        document.body.removeChild(div);\n\n        canvas.width = Math.ceil((Math.max(1, width) + (style.padding * 2)) * resolution);\n        canvas.height = Math.ceil((Math.max(1, height) + (style.padding * 2)) * resolution);\n\n        context.scale(resolution, resolution);\n        context.clearRect(0, 0, canvas.width, canvas.height);\n\n        if (!this._loading)\n        {\n            const image = this._image;\n\n            this._loading = true;\n            image.src = `data:image/svg+xml,${encodeURIComponent(svg)}`;\n            image.onload = () =>\n            {\n                context.drawImage(\n                    image,\n                    0, 0, width, height,\n                    0, 0, width, height,\n                );\n                image.onload = undefined;\n                image.src = '';\n                this._loading = false;\n                this.updateTexture();\n            };\n            this.updateTexture();\n        }\n    }\n\n    /**\n     * Update the texture resource.\n     * @private\n     */\n    updateTexture()\n    {\n        const { canvas, context, style, texture, resolution } = this;\n\n        if (style.trim)\n        {\n            const { width, height, data } = trimCanvas(canvas);\n\n            if (data)\n            {\n                canvas.width = width;\n                canvas.height = height;\n                context.putImageData(data, 0, 0);\n            }\n        }\n\n        const padding = style.trim ? 0 : style.padding;\n        const baseTexture = texture.baseTexture;\n\n        texture.trim.width = texture._frame.width = Math.ceil(canvas.width / resolution);\n        texture.trim.height = texture._frame.height = Math.ceil(canvas.height / resolution);\n        texture.trim.x = -padding;\n        texture.trim.y = -padding;\n\n        texture.orig.width = texture._frame.width - (padding * 2);\n        texture.orig.height = texture._frame.height - (padding * 2);\n\n        // call sprite onTextureUpdate to update scale if _width or _height were set\n        this._onTextureUpdate();\n\n        baseTexture.setRealSize(canvas.width, canvas.height, resolution);\n\n        this.dirty = false;\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @param {PIXI.Renderer} renderer - The renderer\n     * @private\n     */\n    _render(renderer)\n    {\n        if (this._autoResolution && this._resolution !== renderer.resolution)\n        {\n            this._resolution = renderer.resolution;\n            this.dirty = true;\n        }\n\n        this.updateText(true);\n\n        super._render(renderer);\n    }\n\n    /**\n     * Renders the object using the Canvas Renderer.\n     *\n     * @private\n     * @param {PIXI.CanvasRenderer} renderer - The renderer\n     */\n    _renderCanvas(renderer)\n    {\n        if (this._autoResolution && this._resolution !== renderer.resolution)\n        {\n            this._resolution = renderer.resolution;\n            this.dirty = true;\n        }\n\n        this.updateText(true);\n\n        super._renderCanvas(renderer);\n    }\n\n    /**\n     * Get the local bounds.\n     *\n     * @param {PIXI.Rectangle} [rect]\n     * @return {PIXI.Rectangle} Local bounds\n     */\n    getLocalBounds(rect)\n    {\n        this.updateText(true);\n\n        return super.getLocalBounds(rect);\n    }\n\n    _calculateBounds()\n    {\n        this.updateText(true);\n        this.calculateVertices();\n        // if we have already done this on THIS frame.\n        this._bounds.addQuad(this.vertexData);\n    }\n\n    /**\n     * Handle dirty style changes\n     * @private\n     */\n    _onStyleChange()\n    {\n        this.dirty = true;\n    }\n\n    /**\n     * Destroy this Text object. Don't use after calling.\n     * @param {boolean|object} [options=true] Same as Sprite destroy options.\n     */\n    destroy(options = true)\n    {\n        super.destroy(options);\n\n        // make sure to reset the the context and canvas..\n        // dont want this hanging around in memory!\n        this.context = null;\n        this.canvas.width = this.canvas.height = 0; // Safari hack\n        this.canvas = null;\n        this._style = null;\n        this._parser = null;\n        this._image.onload = null;\n        this._image.src = '';\n        this._image = null;\n    }\n\n    /**\n     * Get the width in pixels.\n     * @member {number}\n     */\n    get width()\n    {\n        this.updateText(true);\n\n        return Math.abs(this.scale.x) * this._texture.orig.width;\n    }\n\n    set width(value) // eslint-disable-line require-jsdoc\n    {\n        this.updateText(true);\n\n        const s = sign(this.scale.x) || 1;\n\n        this.scale.x = s * value / this._texture.orig.width;\n        this._width = value;\n    }\n\n    /**\n     * Get the height in pixels.\n     * @member {number}\n     */\n    get height()\n    {\n        this.updateText(true);\n\n        return Math.abs(this.scale.y) * this._texture.orig.height;\n    }\n\n    set height(value) // eslint-disable-line require-jsdoc\n    {\n        this.updateText(true);\n\n        const s = sign(this.scale.y) || 1;\n\n        this.scale.y = s * value / this._texture.orig.height;\n        this._height = value;\n    }\n\n    /**\n     * The base style to render with text.\n     * @member {PIXI.Style|object}\n     */\n    get style()\n    {\n        return this._style;\n    }\n\n    set style(style) // eslint-disable-line require-jsdoc\n    {\n        style = style || {};\n\n        if (style instanceof TextStyle)\n        {\n            this._style = style;\n        }\n        else\n        {\n            this._style = new TextStyle(style);\n        }\n\n        this.localStyleID = -1;\n        this.dirty = true;\n    }\n\n    /**\n     * Contents of text. This can be HTML text.\n     * @member {string}\n     */\n    get text()\n    {\n        return this._text;\n    }\n\n    set text(text) // eslint-disable-line require-jsdoc\n    {\n        text = String(text === '' || text === null || text === undefined ? ' ' : text);\n\n        if (this._text === text)\n        {\n            return;\n        }\n        this._text = text;\n        this.dirty = true;\n    }\n\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.\n     * @member {number}\n     * @default 1\n     */\n    get resolution()\n    {\n        return this._resolution;\n    }\n\n    set resolution(value) // eslint-disable-line require-jsdoc\n    {\n        this._autoResolution = false;\n\n        if (this._resolution === value)\n        {\n            return;\n        }\n\n        this._resolution = value;\n        this.dirty = true;\n    }\n}\n"],"names":["HTMLText","text","style","canvas","document","createElement","width","height","const","texture","Texture","from","scaleMode","settings","SCALE_MODE","orig","Rectangle","trim","super","this","_parser","DOMParser","_image","Image","context","getContext","_resolution","RESOLUTION","_autoResolution","_text","_style","_loading","localStyleID","updateText","respectDirty","styleID","dirty","let","css","lineHeight","wordWrap","breakWords","strokeThickness","color","stroke","hex2string","dropShadow","x","Math","round","cos","dropShadowAngle","dropShadowDistance","y","sin","dropShadowColor","charAt","dropShadowAlpha","hex2rgb","parseInt","replace","dropShadowBlur","svg","div","parseFromString","firstChild","querySelector","body","appendChild","getBoundingClientRect","removeChild","ceil","max","padding","resolution","scale","clearRect","image","src","encodeURIComponent","onload","drawImage","undefined","updateTexture","trimCanvas","data","putImageData","baseTexture","_frame","_onTextureUpdate","setRealSize","_render","renderer","_renderCanvas","getLocalBounds","rect","_calculateBounds","calculateVertices","_bounds","addQuad","vertexData","_onStyleChange","destroy","options","prototypeAccessors","abs","_texture","value","s","sign","_width","_height","TextStyle","String","Sprite"],"mappings":";;;;;;;4DAeaA,cAST,WAAYC,EAAWC,EAAYC,kBAAhB,mBAAY,KAE3BA,EAASA,GAAUC,SAASC,cAAc,WAEnCC,MAAQ,EACfH,EAAOI,OAAS,EAEhBC,IAAMC,EAAUC,UAAQC,KAAKR,EAAQ,CAAES,UAAWC,WAASC,aAE3DL,EAAQM,KAAO,IAAIC,YACnBP,EAAQQ,KAAO,IAAID,YAEnBE,YAAMT,GAENU,KAAKC,QAAU,IAAIC,UACnBF,KAAKG,OAAS,IAAIC,MAElBJ,KAAKhB,OAASA,EACdgB,KAAKK,QAAUL,KAAKhB,OAAOsB,WAAW,MACtCN,KAAKO,YAAcb,WAASc,WAC5BR,KAAKS,iBAAkB,EACvBT,KAAKU,MAAQ,KACbV,KAAKW,OAAS,KACdX,KAAKY,UAAW,EAChBZ,KAAKlB,KAAOA,EACZkB,KAAKjB,MAAQA,EACbiB,KAAKa,cAAgB,iPASzBC,oBAAWC,gBAEwCf,aAAAA,cAAAA,eAAAA,gBAS/C,GANIA,KAAKa,eAAiB9B,EAAMiC,UAE5BhB,KAAKiB,OAAQ,EACbjB,KAAKa,aAAe9B,EAAMiC,SAGzBhB,KAAKiB,QAASF,EAAnB,CAKAG,IAAIC,EAAM,0DAEEpC,oCACKA,2CACCA,2CACAA,0CACDA,2CACEA,+CACEA,+CACJA,kCACHA,0BAcd,GAXIA,EAAMqC,aAEND,GAAO,eAAepC,oBAGtBA,EAAMsC,WAENF,GAAO,cAAapC,EAAMuC,WAAa,YAAc,kBACrDH,GAAO,SAASpC,uBAGhBA,EAAMwC,gBACV,CACU,eAEe,iBAAVC,QAEPC,EAASC,aAAWD,IAGxBN,GAAO,8BAA8BpC,wBACrCoC,GAAO,8BAA8BM,MACrCN,GAAO,sBAAsBpC,wBAC7BoC,GAAO,sBAAsBM,MAC7BN,GAAO,uBAGX,GAAIpC,EAAM4C,WACV,CACY,0GACFC,EAAIC,KAAKC,MAAMD,KAAKE,IAAIC,GAAmBC,GAC3CC,EAAIL,KAAKC,MAAMD,KAAKM,IAAIH,GAAmBC,GAC7CT,EAAQY,EASZ,GANqB,iBAAVZ,IAEPA,EAAQE,aAAWF,IAIC,MAApBA,EAAMa,OAAO,IAAcC,EAAkB,EACjD,OACsBC,UAAQC,SAAShB,EAAMiB,QAAQ,IAAK,IAAK,KAE3DjB,EAAQ,SAAY,SAAM,SAAU,SAAM,SAAU,SAAM,QAAMc,MAGpEnB,GAAO,gBAAgBS,QAAOM,QAAOQ,QAAoBlB,MAG7DnC,IAAMsD,EAAM,uNAGmDxB,OAAQnB,mFAOjE4C,EADW5C,KAAKC,QAAQ4C,gBAAgBF,EAAK,YAC9BG,WAAWC,cAAc,OAE9C9D,SAAS+D,KAAKC,YAAYL,SACAA,EAAIM,6CAU9B,GARAjE,SAAS+D,KAAKG,YAAYP,GAE1B5D,EAAOG,MAAQ0C,KAAKuB,MAAMvB,KAAKwB,IAAI,EAAGlE,GAA0B,EAAhBJ,EAAMuE,SAAgBC,GACtEvE,EAAOI,OAASyC,KAAKuB,MAAMvB,KAAKwB,IAAI,EAAGjE,GAA2B,EAAhBL,EAAMuE,SAAgBC,GAExElD,EAAQmD,MAAMD,EAAYA,GAC1BlD,EAAQoD,UAAU,EAAG,EAAGzE,EAAOG,MAAOH,EAAOI,SAExCY,KAAKY,SACV,CACIvB,IAAMqE,EAAQ1D,KAAKG,OAEnBH,KAAKY,UAAW,EAChB8C,EAAMC,IAAM,sBAAsBC,mBAAmBjB,GACrDe,EAAMG,kBAEFxD,EAAQyD,UACJJ,EACA,EAAG,EAAGvE,EAAOC,EACb,EAAG,EAAGD,EAAOC,GAEjBsE,EAAMG,YAASE,EACfL,EAAMC,IAAM,GACZ3D,EAAKY,UAAW,EAChBZ,EAAKgE,iBAEThE,KAAKgE,+BAQbA,+BAE4DhE,cAAAA,eAAAA,aAAAA,eAAAA,gBAExD,GAAIjB,EAAMe,KACV,OACoCmE,aAAWjF,iCAEvCkF,IAEAlF,EAAOG,MAAQA,EACfH,EAAOI,OAASA,EAChBiB,EAAQ8D,aAAaD,EAAM,EAAG,IAItC7E,IAAMiE,EAAUvE,EAAMe,KAAO,EAAIf,EAAMuE,QACjCc,EAAc9E,EAAQ8E,YAE5B9E,EAAQQ,KAAKX,MAAQG,EAAQ+E,OAAOlF,MAAQ0C,KAAKuB,KAAKpE,EAAOG,MAAQoE,GACrEjE,EAAQQ,KAAKV,OAASE,EAAQ+E,OAAOjF,OAASyC,KAAKuB,KAAKpE,EAAOI,OAASmE,GACxEjE,EAAQQ,KAAK8B,GAAK0B,EAClBhE,EAAQQ,KAAKoC,GAAKoB,EAElBhE,EAAQM,KAAKT,MAAQG,EAAQ+E,OAAOlF,MAAmB,EAAVmE,EAC7ChE,EAAQM,KAAKR,OAASE,EAAQ+E,OAAOjF,OAAoB,EAAVkE,EAG/CtD,KAAKsE,mBAELF,EAAYG,YAAYvF,EAAOG,MAAOH,EAAOI,OAAQmE,GAErDvD,KAAKiB,OAAQ,eASjBuD,iBAAQC,GAEAzE,KAAKS,iBAAmBT,KAAKO,cAAgBkE,EAASlB,aAEtDvD,KAAKO,YAAckE,EAASlB,WAC5BvD,KAAKiB,OAAQ,GAGjBjB,KAAKc,YAAW,GAEhBf,YAAMyE,kBAAQC,gBASlBC,uBAAcD,GAENzE,KAAKS,iBAAmBT,KAAKO,cAAgBkE,EAASlB,aAEtDvD,KAAKO,YAAckE,EAASlB,WAC5BvD,KAAKiB,OAAQ,GAGjBjB,KAAKc,YAAW,GAEhBf,YAAM2E,wBAAcD,gBASxBE,wBAAeC,GAIX,OAFA5E,KAAKc,YAAW,GAETf,YAAM4E,yBAAeC,gBAGhCC,4BAEI7E,KAAKc,YAAW,GAChBd,KAAK8E,oBAEL9E,KAAK+E,QAAQC,QAAQhF,KAAKiF,yBAO9BC,0BAEIlF,KAAKiB,OAAQ,eAOjBkE,iBAAQC,mBAAU,GAEdrF,YAAMoF,kBAAQC,GAIdpF,KAAKK,QAAU,KACfL,KAAKhB,OAAOG,MAAQa,KAAKhB,OAAOI,OAAS,EACzCY,KAAKhB,OAAS,KACdgB,KAAKW,OAAS,KACdX,KAAKC,QAAU,KACfD,KAAKG,OAAO0D,OAAS,KACrB7D,KAAKG,OAAOwD,IAAM,GAClB3D,KAAKG,OAAS,MAOlBkF,EAAIlG,qBAIA,OAFAa,KAAKc,YAAW,GAETe,KAAKyD,IAAItF,KAAKwD,MAAM5B,GAAK5B,KAAKuF,SAAS3F,KAAKT,OAGvDkG,EAAIlG,mBAAMqG,GAENxF,KAAKc,YAAW,GAEhBzB,IAAMoG,EAAIC,OAAK1F,KAAKwD,MAAM5B,IAAM,EAEhC5B,KAAKwD,MAAM5B,EAAI6D,EAAID,EAAQxF,KAAKuF,SAAS3F,KAAKT,MAC9Ca,KAAK2F,OAASH,GAOlBH,EAAIjG,sBAIA,OAFAY,KAAKc,YAAW,GAETe,KAAKyD,IAAItF,KAAKwD,MAAMtB,GAAKlC,KAAKuF,SAAS3F,KAAKR,QAGvDiG,EAAIjG,oBAAOoG,GAEPxF,KAAKc,YAAW,GAEhBzB,IAAMoG,EAAIC,OAAK1F,KAAKwD,MAAMtB,IAAM,EAEhClC,KAAKwD,MAAMtB,EAAIuD,EAAID,EAAQxF,KAAKuF,SAAS3F,KAAKR,OAC9CY,KAAK4F,QAAUJ,GAOnBH,EAAItG,qBAEA,OAAOiB,KAAKW,QAGhB0E,EAAItG,mBAAMA,IAENA,EAAQA,GAAS,cAEI8G,YAEjB7F,KAAKW,OAAS5B,EAIdiB,KAAKW,OAAS,IAAIkF,YAAU9G,GAGhCiB,KAAKa,cAAgB,EACrBb,KAAKiB,OAAQ,GAOjBoE,EAAIvG,oBAEA,OAAOkB,KAAKU,OAGhB2E,EAAIvG,kBAAKA,GAELA,EAAOgH,OAAgB,KAAThH,GAAAA,MAAeA,EAAsC,IAAMA,GAErEkB,KAAKU,QAAU5B,IAInBkB,KAAKU,MAAQ5B,EACbkB,KAAKiB,OAAQ,IASjBoE,EAAI9B,0BAEA,OAAOvD,KAAKO,aAGhB8E,EAAI9B,wBAAWiC,GAEXxF,KAAKS,iBAAkB,EAEnBT,KAAKO,cAAgBiF,IAKzBxF,KAAKO,YAAciF,EACnBxF,KAAKiB,OAAQ,8CAtZS8E"}