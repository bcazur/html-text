{"version":3,"file":"html-text.cjs.js","sources":["../src/index.js"],"sourcesContent":["import { Sprite } from '@pixi/sprite';\nimport { settings } from '@pixi/settings';\nimport { Texture } from '@pixi/core';\nimport { Rectangle } from '@pixi/math';\nimport { trimCanvas, sign, hex2rgb, hex2string } from '@pixi/utils';\nimport { TextStyle } from '@pixi/text';\n\n/**\n * Text display object that support multi-style HTML text\n * @class\n * @memberof PIXI\n * @extends PIXI.Sprite\n * @see {@link https://pixijs.download/dev/docs/PIXI.Sprite.html PIXI.Sprite}\n * @see {@link https://pixijs.download/dev/docs/PIXI.TextStyle.html PIXI.TextStyle}\n */\nexport class HTMLText extends Sprite\n{\n    /**\n     * @constructor\n     * @param {string} [text] - Text contents\n     * @param {PIXI.TextStyle} [style] - Style settings, not all TextStyle options are supported.\n     * @param {HTMLCanvasElement} [canvas] - Optional canvas to use for rendering.\n     *.       if undefined, will generate it's own canvas using createElement.\n     */\n    constructor(text = '', style = {}, canvas)\n    {\n        if (typeof btoa === 'undefined')\n        {\n            throw new Error('Your browser doesn\\'t support base64 conversions.');\n        }\n\n        canvas = canvas || document.createElement('canvas');\n\n        canvas.width = 3;\n        canvas.height = 3;\n\n        const texture = Texture.from(canvas, { scaleMode: settings.SCALE_MODE });\n\n        texture.orig = new Rectangle();\n        texture.trim = new Rectangle();\n\n        super(texture);\n\n        this._parser = new DOMParser();\n        this._image = new Image();\n\n        this.canvas = canvas;\n        this.context = this.canvas.getContext('2d');\n        this._resolution = settings.RESOLUTION;\n        this._autoResolution = true;\n        this._text = null;\n        this._style = null;\n        this._loading = false;\n        this.text = text;\n        this.style = style;\n        this.localStyleID = -1;\n    }\n\n    /**\n     * Manually refresh the text.\n     * @public\n     * @param {boolean} [respectDirty=true] - Whether to abort updating the\n     *        text if the Text isn't dirty and the function is called.\n     */\n    updateText(respectDirty)\n    {\n        const { style, canvas, context, resolution } = this;\n\n        // check if style has changed..\n        if (this.localStyleID !== style.styleID)\n        {\n            this.dirty = true;\n            this.localStyleID = style.styleID;\n        }\n\n        if (!this.dirty && respectDirty)\n        {\n            return;\n        }\n\n        let css = `\n            display:inline-block;\n            color:${style.fill};\n            font-size: ${style.fontSize}px;\n            font-family:${style.fontFamily};\n            font-weight:${style.fontWeight};\n            font-style:${style.fontStyle};\n            font-variant:${style.fontVariant};\n            letter-spacing:${style.letterSpacing}px;\n            text-align:${style.align};\n            padding:${style.padding}px;\n        `;\n\n        if (style.lineHeight)\n        {\n            css += `line-height:${style.lineHeight}px;`;\n        }\n\n        if (style.wordWrap)\n        {\n            css += `word-wrap:${style.breakWords ? 'break-all' : 'break-word'};`;\n            css += `width:${style.wordWrapWidth}px;`;\n        }\n\n        if (style.strokeThickness)\n        {\n            let { stroke } = style;\n\n            if (typeof color === 'number')\n            {\n                stroke = hex2string(stroke);\n            }\n\n            css += `-webkit-text-stroke-width: ${style.strokeThickness}px;`;\n            css += `-webkit-text-stroke-color: ${stroke};`;\n            css += `text-stroke-width: ${style.strokeThickness}px;`;\n            css += `text-stroke-color: ${stroke};`;\n            css += 'paint-order: stroke;';\n        }\n\n        if (style.dropShadow)\n        {\n            const { dropShadowAngle, dropShadowDistance, dropShadowBlur, dropShadowColor, dropShadowAlpha } = style;\n            const x = Math.round(Math.cos(dropShadowAngle) * dropShadowDistance);\n            const y = Math.round(Math.sin(dropShadowAngle) * dropShadowDistance);\n            let color = dropShadowColor;\n\n            // Convert numbers to hex strings\n            if (typeof color === 'number')\n            {\n                color = hex2string(color);\n            }\n\n            // Check if we should apply alpha\n            if (color.charAt(0) === '#' && dropShadowAlpha < 1)\n            {\n                const [r, g, b] = hex2rgb(parseInt(color.replace('#', ''), 16));\n\n                color = `rgba(${r * 255 | 0}, ${g * 255 | 0}, ${b * 255 | 0}, ${dropShadowAlpha})`;\n            }\n\n            css += `text-shadow: ${x}px ${y}px ${dropShadowBlur}px ${color};`;\n        }\n\n        const svg = `\n            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"2048\" height=\"2048\">\n                <foreignObject width=\"100%\" height=\"100%\">\n                    <div xmlns=\"http://www.w3.org/1999/xhtml\" style=\"${css}\">${this._text}</div>\n                </foreignObject>\n            </svg>\n       `;\n\n        // Used to measure to D\n        const template = this._parser.parseFromString(svg, 'text/xml');\n        const div = template.firstChild.querySelector('div');\n\n        document.body.appendChild(div);\n        const { width, height } = div.getBoundingClientRect();\n\n        document.body.removeChild(div);\n\n        canvas.width = Math.ceil((Math.max(1, width) + (style.padding * 2)) * resolution);\n        canvas.height = Math.ceil((Math.max(1, height) + (style.padding * 2)) * resolution);\n\n        context.scale(resolution, resolution);\n        context.clearRect(0, 0, canvas.width, canvas.height);\n\n        if (!this._loading)\n        {\n            const image = this._image;\n\n            this._loading = true;\n            image.src = `data:image/svg+xml;base64,${btoa(svg)}`;\n            image.onload = () =>\n            {\n                context.drawImage(\n                    image,\n                    0, 0, width, height,\n                    0, 0, width, height,\n                );\n                image.onload = undefined;\n                image.src = '';\n                this._loading = false;\n                this.updateTexture();\n            };\n            this.updateTexture();\n        }\n    }\n\n    /**\n     * Update the texture resource.\n     * @private\n     */\n    updateTexture()\n    {\n        const { canvas, context, style, texture, resolution } = this;\n\n        if (style.trim)\n        {\n            const { width, height, data } = trimCanvas(canvas);\n\n            if (data)\n            {\n                canvas.width = width;\n                canvas.height = height;\n                context.putImageData(data, 0, 0);\n            }\n        }\n\n        const padding = style.trim ? 0 : style.padding;\n        const baseTexture = texture.baseTexture;\n\n        texture.trim.width = texture._frame.width = Math.ceil(canvas.width / resolution);\n        texture.trim.height = texture._frame.height = Math.ceil(canvas.height / resolution);\n        texture.trim.x = -padding;\n        texture.trim.y = -padding;\n\n        texture.orig.width = texture._frame.width - (padding * 2);\n        texture.orig.height = texture._frame.height - (padding * 2);\n\n        // call sprite onTextureUpdate to update scale if _width or _height were set\n        this._onTextureUpdate();\n\n        baseTexture.setRealSize(canvas.width, canvas.height, resolution);\n\n        this.dirty = false;\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @param {PIXI.Renderer} renderer - The renderer\n     * @private\n     */\n    _render(renderer)\n    {\n        if (this._autoResolution && this._resolution !== renderer.resolution)\n        {\n            this._resolution = renderer.resolution;\n            this.dirty = true;\n        }\n\n        this.updateText(true);\n\n        super._render(renderer);\n    }\n\n    /**\n     * Renders the object using the Canvas Renderer.\n     *\n     * @private\n     * @param {PIXI.CanvasRenderer} renderer - The renderer\n     */\n    _renderCanvas(renderer)\n    {\n        if (this._autoResolution && this._resolution !== renderer.resolution)\n        {\n            this._resolution = renderer.resolution;\n            this.dirty = true;\n        }\n\n        this.updateText(true);\n\n        super._renderCanvas(renderer);\n    }\n\n    /**\n     * Get the local bounds.\n     *\n     * @param {PIXI.Rectangle} [rect]\n     * @return {PIXI.Rectangle} Local bounds\n     */\n    getLocalBounds(rect)\n    {\n        this.updateText(true);\n\n        return super.getLocalBounds(rect);\n    }\n\n    _calculateBounds()\n    {\n        this.updateText(true);\n        this.calculateVertices();\n        // if we have already done this on THIS frame.\n        this._bounds.addQuad(this.vertexData);\n    }\n\n    /**\n     * Handle dirty style changes\n     * @private\n     */\n    _onStyleChange()\n    {\n        this.dirty = true;\n    }\n\n    /**\n     * Destroy this Text object. Don't use after calling.\n     * @param {boolean|object} [options=true] Same as Sprite destroy options.\n     */\n    destroy(options = true)\n    {\n        super.destroy(options);\n\n        // make sure to reset the the context and canvas..\n        // dont want this hanging around in memory!\n        this.context = null;\n        this.canvas.width = this.canvas.height = 0; // Safari hack\n        this.canvas = null;\n        this._style = null;\n        this._parser = null;\n        this._image.onload = null;\n        this._image.src = '';\n        this._image = null;\n    }\n\n    /**\n     * Get the width in pixels.\n     * @member {number}\n     */\n    get width()\n    {\n        this.updateText(true);\n\n        return Math.abs(this.scale.x) * this._texture.orig.width;\n    }\n\n    set width(value) // eslint-disable-line require-jsdoc\n    {\n        this.updateText(true);\n\n        const s = sign(this.scale.x) || 1;\n\n        this.scale.x = s * value / this._texture.orig.width;\n        this._width = value;\n    }\n\n    /**\n     * Get the height in pixels.\n     * @member {number}\n     */\n    get height()\n    {\n        this.updateText(true);\n\n        return Math.abs(this.scale.y) * this._texture.orig.height;\n    }\n\n    set height(value) // eslint-disable-line require-jsdoc\n    {\n        this.updateText(true);\n\n        const s = sign(this.scale.y) || 1;\n\n        this.scale.y = s * value / this._texture.orig.height;\n        this._height = value;\n    }\n\n    /**\n     * The base style to render with text.\n     * @member {PIXI.Style|object}\n     */\n    get style()\n    {\n        return this._style;\n    }\n\n    set style(style) // eslint-disable-line require-jsdoc\n    {\n        style = style || {};\n\n        if (style instanceof TextStyle)\n        {\n            this._style = style;\n        }\n        else\n        {\n            this._style = new TextStyle(style);\n        }\n\n        this.localStyleID = -1;\n        this.dirty = true;\n    }\n\n    /**\n     * Contents of text. This can be HTML text.\n     * @member {string}\n     */\n    get text()\n    {\n        return this._text;\n    }\n\n    set text(text) // eslint-disable-line require-jsdoc\n    {\n        text = String(text === '' || text === null || text === undefined ? ' ' : text);\n\n        if (this._text === text)\n        {\n            return;\n        }\n        this._text = text;\n        this.dirty = true;\n    }\n\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.\n     * @member {number}\n     * @default 1\n     */\n    get resolution()\n    {\n        return this._resolution;\n    }\n\n    set resolution(value) // eslint-disable-line require-jsdoc\n    {\n        this._autoResolution = false;\n\n        if (this._resolution === value)\n        {\n            return;\n        }\n\n        this._resolution = value;\n        this.dirty = true;\n    }\n}\n"],"names":["HTMLText","text","style","canvas","btoa","Error","document","createElement","width","height","const","texture","Texture","from","scaleMode","settings","SCALE_MODE","orig","Rectangle","trim","super","this","_parser","DOMParser","_image","Image","context","getContext","_resolution","RESOLUTION","_autoResolution","_text","_style","_loading","localStyleID","updateText","respectDirty","styleID","dirty","let","css","lineHeight","wordWrap","breakWords","strokeThickness","color","stroke","hex2string","dropShadow","x","Math","round","cos","dropShadowAngle","dropShadowDistance","y","sin","dropShadowColor","charAt","dropShadowAlpha","hex2rgb","parseInt","replace","dropShadowBlur","svg","div","parseFromString","firstChild","querySelector","body","appendChild","getBoundingClientRect","removeChild","ceil","max","padding","resolution","scale","clearRect","image","src","onload","drawImage","undefined","updateTexture","trimCanvas","data","putImageData","baseTexture","_frame","_onTextureUpdate","setRealSize","_render","renderer","_renderCanvas","getLocalBounds","rect","_calculateBounds","calculateVertices","_bounds","addQuad","vertexData","_onStyleChange","destroy","options","prototypeAccessors","abs","_texture","value","s","sign","_width","_height","TextStyle","String","Sprite"],"mappings":"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"}