<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>PixiJS HTMLText</title>
    
    <meta name="description" content="API Documentation for HTMLText for PixiJS" />
    
        <meta name="keywords" content="PixiJS, Text, canvas, rendering, typography, CSS, SVG" />
        <meta name="keyword" content="PixiJS, Text, canvas, rendering, typography, CSS, SVG" />
    
    
    
    
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <script src="scripts/jquery.min.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link href="https://fonts.googleapis.com/css?family=Libre+Franklin:400,700" rel="stylesheet">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/bootstrap.min.css">
    <link type="text/css" rel="stylesheet" href="styles/main.css">

    
    <script>
    var config = {"monospaceLinks":false,"cleverLinks":false,"applicationName":"PixiJS HTMLText","meta":{"title":"PixiJS HTMLText","description":"API Documentation for HTMLText for PixiJS","keyword":"PixiJS, Text, canvas, rendering, typography, CSS, SVG"},"linenums":true,"default":{"outputSourceFiles":true}};
    </script>
    

    
</head>
<body>
<div id="wrap" class="clearfix">
    
<div class="navigation">
    <h3 class="applicationName"><a href="index.html">PixiJS HTMLText</a></h3>
    <button id="menuToggle" class="btn btn-link btn-lg menu-toggle">
        <span class="glyphicon glyphicon-menu-hamburger"></span>
    </button>
    <div class="search">
        <input id="search" type="text" class="form-control input-md" placeholder="Search...">
    </div>
    <ul class="list">
    
    
        <li class="item" data-name="PIXI.HTMLText">
            <span class="title  ">
                
                
                    <a href="PIXI.HTMLText.html">PIXI.HTMLText</a>
                
            </span>
            
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li class="parent " data-name="PIXI.HTMLText#height"><a href="PIXI.HTMLText.html#height">height</a></li>
            
                <li class="parent " data-name="PIXI.HTMLText#style"><a href="PIXI.HTMLText.html#style">style</a></li>
            
                <li class="parent " data-name="PIXI.HTMLText#text"><a href="PIXI.HTMLText.html#text">text</a></li>
            
                <li class="parent " data-name="PIXI.HTMLText#width"><a href="PIXI.HTMLText.html#width">width</a></li>
            
            </ul>
            
            <ul class="typedefs itemMembers">
            
            </ul>
            
            <ul class="typedefs itemMembers">
            
            </ul>
            
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li class="parent  " data-name="PIXI.HTMLText#destroy"><a href="PIXI.HTMLText.html#destroy">destroy</a></li>
            
                <li class="parent  " data-name="PIXI.HTMLText#getLocalBounds"><a href="PIXI.HTMLText.html#getLocalBounds">getLocalBounds</a></li>
            
                <li class="parent  " data-name="PIXI.HTMLText#render"><a href="PIXI.HTMLText.html#render">render</a></li>
            
                <li class="parent  " data-name="PIXI.HTMLText#updateText"><a href="PIXI.HTMLText.html#updateText">updateText</a></li>
            
            </ul>
            
            <ul class="events itemMembers">
            
            </ul>
            
        </li>
    
    </ul>
</div>

    <div class="main">
        <h1 class="page-title" data-filename="-_Users_mattkarl_GitHub_pixijs_pixi-html-text_src_index.js.html">Source: /Users/mattkarl/GitHub/pixijs/pixi-html-text/src/index.js</h1>
        


    
    <section>
        <header>
            <div class="header content-size">
                <h2>/Users/mattkarl/GitHub/pixijs/pixi-html-text/src/index.js</h2>
            </div>
        </header>
        <article>
            <pre id="source-code" class="prettyprint source linenums"><code>import { Sprite } from '@pixi/sprite';
import { settings } from '@pixi/settings';
import { Texture } from '@pixi/core';
import { Rectangle } from '@pixi/math';
import { trimCanvas, sign } from '@pixi/utils';
import { TextStyle } from '@pixi/text';

/**
 * Text display object that support multi-style HTML text
 * @class
 * @memberof PIXI
 * @extends PIXI.Sprite
 * @see {@link https://pixijs.download/dev/docs/PIXI.Sprite.html PIXI.Sprite}
 * @see {@link https://pixijs.download/dev/docs/PIXI.TextStyle.html PIXI.TextStyle}
 */
export class HTMLText extends Sprite
{
    /**
     * @constructor
     * @param {string} [text] - Text contents
     * @param {PIXI.TextStyle} [style] - Style settings, not all TextStyle options are supported.
     * @param {HTMLCanvasElement} [canvas] - Optional canvas to use for rendering.
     *.       if undefined, will generate it's own canvas using createElement.
     */
    constructor(text = "", style = {}, canvas)
    {
        if (typeof btoa === 'undefined')
        {
            throw new Error('Your browser doesn\'t support base64 conversions.');
        }

        canvas = canvas || document.createElement('canvas');

        canvas.width = 3;
        canvas.height = 3;

        const texture = Texture.from(canvas, { scaleMode: settings.SCALE_MODE });

        texture.orig = new Rectangle();
        texture.trim = new Rectangle();

        super(texture);

        this._parser = new DOMParser();
        this._image = new Image();

        this.canvas = canvas;
        this.context = this.canvas.getContext('2d');
        this.resolution = settings.RESOLUTION;
        this._text = null;
        this._style = null;
        this.text = text;
        this.style = style;
        this.localStyleID = -1;
    }

    /**
     * Manually refresh the text.
     * @public
     * @param {boolean} [respectDirty=true] - Whether to abort updating the
     *        text if the Text isn't dirty and the function is called.
     */
    updateText(respectDirty = true)
    {
        const style = this._style;

        // check if style has changed..
        if (this.localStyleID !== style.styleID)
        {
            this.dirty = true;
            this.localStyleID = style.styleID;
        }

        if (!this.dirty &amp;&amp; respectDirty)
        {
            return;
        }

        const { canvas, context, resolution } = this;

        let css = `
            display:inline-block;
            color:${style.fill};
            font-size: ${style.fontSize}px;
            font-family:${style.fontFamily};
            font-weight:${style.fontWeight};
            font-style:${style.fontStyle};
            font-variant:${style.fontVariant};
            letter-spacing:${style.letterSpacing}px;
            text-align:${style.align};
            padding:${style.padding}px;
        `;

        if (style.breakWords)
        {
            css += 'word-break:break-all;';
        }

        if (style.lineHeight)
        {
            css += `line-height:${style.lineHeight}px;`;
        }

        if (style.wordWrap)
        {
            css += 'word-wrap:break-word;';
            css += `width:${style.wordWrapWidth}px;`;
        }

        if (style.strokeThickness)
        {
            css += `-webkit-text-stroke-width: ${style.strokeThickness}px;`;
            css += `-webkit-text-stroke-color: ${style.stroke};`;
            css += `text-stroke-width: ${style.strokeThickness}px;`;
            css += `text-stroke-color: ${style.stroke};`;
        }

        if (style.dropShadow)
        {
            const x = Math.round(Math.cos(style.dropShadowAngle) * style.dropShadowDistance);
            const y = Math.round(Math.sin(style.dropShadowAngle) * style.dropShadowDistance);

            css += `text-shadow: ${x}px ${y}px ${style.dropShadowBlur}px ${style.dropShadowColor};`;
        }

        const svg = `
            &lt;svg xmlns="http://www.w3.org/2000/svg" width="2048" height="2048">
                &lt;foreignObject width="100%" height="100%">
                    &lt;div xmlns="http://www.w3.org/1999/xhtml" style="${css}">${this._text}&lt;/div>
                &lt;/foreignObject>
            &lt;/svg>
       `;

        // Used to measure to D
        const template = this._parser.parseFromString(svg, 'text/xml');
        const div = template.firstChild.querySelector('div');

        document.body.appendChild(div);
        const { width, height } = div.getBoundingClientRect();

        document.body.removeChild(div);

        canvas.width = Math.ceil(width * resolution);
        canvas.height = Math.ceil(height * resolution);

        context.scale(resolution, resolution);
        context.clearRect(0, 0, canvas.width, canvas.height);

        this.updateTexture();

        const image = this._image;

        image.src = `data:image/svg+xml;base64,${btoa(svg)}`;
        image.onload = () =>
        {
            context.drawImage(
                image,
                0, 0, width, height,
                0, 0, width, height,
            );
            image.onload = undefined;
            image.src = '';
        };
    }

    /**
     * Update the texture resource.
     * @private
     */
    updateTexture()
    {
        const { canvas, context, style, texture, resolution } = this;

        if (style.trim)
        {
            const trimmed = trimCanvas(canvas);

            canvas.width = trimmed.width;
            canvas.height = trimmed.height;
            context.putImageData(trimmed.data, 0, 0);
        }

        const padding = style.trim ? 0 : style.padding;
        const baseTexture = texture.baseTexture;

        baseTexture.valid = true;
        baseTexture.resolution = resolution;

        // baseTexture.realWidth = canvas.width;
        // baseTexture.realHeight = canvas.height;
        baseTexture.width = canvas.width / resolution;
        baseTexture.height = canvas.height / resolution;

        texture.trim.width = texture._frame.width = canvas.width / resolution;
        texture.trim.height = texture._frame.height = canvas.height / resolution;
        texture.trim.x = -padding;
        texture.trim.y = -padding;

        texture.orig.width = texture._frame.width - (padding * 2);
        texture.orig.height = texture._frame.height - (padding * 2);

        // call sprite onTextureUpdate to update scale if _width or _height were set
        this._onTextureUpdate();

        baseTexture.emit('update', baseTexture);

        this.dirty = false;
    }

    /**
     * Renders the object using the WebGL renderer
     *
     * @param {PIXI.Renderer} renderer - The renderer
     */
    render(renderer)
    {
        if (this.resolution !== renderer.resolution)
        {
            this.resolution = renderer.resolution;
            this.dirty = true;
        }

        this.updateText();

        super.render(renderer);
    }

    /**
     * Renders the object using the Canvas Renderer.
     *
     * @private
     * @param {PIXI.CanvasRenderer} renderer - The renderer
     */
    _renderCanvas(renderer)
    {
        if (this.resolution !== renderer.resolution)
        {
            this.resolution = renderer.resolution;
            this.dirty = true;
        }

        this.updateText();

        super._renderCanvas(renderer);
    }

    /**
     * Get the local bounds.
     *
     * @param {PIXI.Rectangle} [rect]
     * @return {PIXI.Rectangle} Local bounds
     */
    getLocalBounds(rect)
    {
        this.updateText();

        return super.getLocalBounds(rect);
    }

    _calculateBounds()
    {
        this.updateText();
        this.calculateVertices();
        // if we have already done this on THIS frame.
        this._bounds.addQuad(this.vertexData);
    }

    /**
     * Handle dirty style changes
     * @private
     */
    _onStyleChange()
    {
        this.dirty = true;
    }

    /**
     * Destroy this Text object. Don't use after calling.
     * @param {boolean|object} [options=true] Same as Sprite destroy options.
     */
    destroy(options = true)
    {
        super.destroy(options);

        // make sure to reset the the context and canvas..
        // dont want this hanging around in memory!
        this.context = null;
        this.canvas.width = this.canvas.height = 0; // Safari hack
        this.canvas = null;
        this._style = null;
    }

    /**
     * Get the width in pixels.
     * @member {number}
     */
    get width()
    {
        this.updateText();

        return Math.abs(this.scale.x) * this._texture.orig.width;
    }

    set width(value) // eslint-disable-line require-jsdoc
    {
        this.updateText();

        const s = sign(this.scale.x) || 1;

        this.scale.x = s * value / this._texture.orig.width;
        this._width = value;
    }

    /**
     * Get the height in pixels.
     * @member {number}
     */
    get height()
    {
        this.updateText();

        return Math.abs(this.scale.y) * this._texture.orig.height;
    }

    set height(value) // eslint-disable-line require-jsdoc
    {
        this.updateText();

        const s = sign(this.scale.y) || 1;

        this.scale.y = s * value / this._texture.orig.height;
        this._height = value;
    }

    /**
     * The base style to render with text.
     * @member {PIXI.Style|object}
     */
    get style()
    {
        return this._style;
    }

    set style(style) // eslint-disable-line require-jsdoc
    {
        style = style || {};

        if (style instanceof TextStyle)
        {
            this._style = style;
        }
        else
        {
            this._style = new TextStyle(style);
        }

        this.localStyleID = -1;
        this.dirty = true;
    }

    /**
     * Contents of text. This can be HTML text.
     * @member {string}
     */
    get text()
    {
        return this._text;
    }

    set text(text) // eslint-disable-line require-jsdoc
    {
        text = String(text === '' || text === null || text === undefined ? ' ' : text);

        if (this._text === text)
        {
            return;
        }
        this._text = text;
        this.dirty = true;
    }
}
</code></pre>
        </article>
    </section>






        

        <footer class="content-size">
            <div class="footer">
                Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> on Mon Apr 06 2020 10:41:39 GMT-0700 (Pacific Daylight Time)
            </div>
        </footer>
    </div>
</div>
<script>prettyPrint();</script>
<script src="scripts/main.js"></script>


</body>
</html>
